' See https://qb64.com/wiki/FILES for details on get directory.GetAllFiles


'$INCLUDE:'.\constants.bi'
'$INCLUDE:'.\file.bm'
'$INCLUDE:'.\path.bm'

$if ddlibDirectory = undefined then
$let ddlibDirectory = define

' ----------------------------------------------------------------------------
' #### Determines whether the given path refers to an existing directory on disk.
'___
' - @param {string} path The path to test
function directory.Exists(path as string)
	if _direxists(path) then
		directory.Exists = boolean.TRUE
	else
		directory.Exists = boolean.FALSE
	end if
end function
' ----------------------------------------------------------------------------
' #### Creates a new folder (directory) at a specified path.
'___
' - @param {string} path The directory to create.
function directory.CreateDirectory(path as string)
	if not directory.Exists(path) then
		mkdir path
	end if
	directory.CreateDirectory = directory.Exists(path)
end function
' ----------------------------------------------------------------------------
' #### Deletes an empty directory using a designated path relative to the present path location.
'___
' - @param {string} path The directory to delete.
sub directory.Delete(path as string)
	if directory.Exists(path) then
		rmdir path
	end if
end sub
' ----------------------------------------------------------------------------
'___
' #### Returns the names of files that meet specified criteria
'___
' - @param {string} path The relative or absolute path to the directory to search. This string is not case-sensitive.
' path can use the * and ? wildcard specifications:
' * denotes one or more wildcard characters in a filename or path specification as any legal file name character(s).
' ? denotes one wildcard letter in a filename or path specification as any legal filename character.
'
' - @param {string} path Search path.
' - @param {string array} Array to put files in
sub directory.GetFiles(path as string, fileArray() as string, includeSubFolders as integer)
	dim shellCommand as string : shellCommand = string.EMPTY
	if instr(_os$,"[WINDOWS]") > 0 then
		if includeSubFolders = boolean.TRUE then
			shellCommand = "dir " + path.AddSlash(path) + "*.* /on/s/b/d/a-d"
		else
			shellCommand = "dir " + path.AddSlash(path) + "*.* /on/b/d/a-d"
		end if
	else
		shellCommand = "ls -l " + path.AddSlash(path) + " /b"
	end if
	
	call directory.RunDirToFileAndLoadArray(shellCommand, fileArray())
	
end sub
' ----------------------------------------------------------------------------
sub directory.GetFolders(path as string, fileArray() as string, includeSubFolders as integer)
	
	dim shellCommand as string : shellCommand = string.EMPTY
	if instr(_os$,"[WINDOWS]") > 0 then
		if includeSubFolders = boolean.TRUE then
			shellCommand = "dir " + path.AddSlash(path$) + "*.* /on/b/s/AD"
		else
			shellCommand = "dir " + path.AddSlash(path$) + "*.* /on/b/AD"
		end if
	else
		shellCommand = "ls -l --sort=time --reverse --color=always --time-style=long-iso --group-directories-first --recursive --all --directory " + path
	end if
	
	call directory.RunDirToFileAndLoadArray(shellCommand, fileArray())
	
end sub
' ----------------------------------------------------------------------------
' Interal sub to load a temp file with files or folders the read the file.
sub directory.RunDirToFileAndLoadArray(shellCommand as string, fileArray() as string)
	
	redim	fileArray(1 to 0)
	if shellCommand = string.EMPTY then
		exit sub
	end if
	
	dim listMAX as integer : listMAX = 2000 'change maximum to suit your needs
	dim tmpfile as string : tmpfile = "ddlib-dir$inf" + ltrim$(str$(rnd)) + ".tmp" ' Test RND
	shell _hide shellCommand + " > " + tmpfile
	
	if file.GetSize(tmpfile) = long.EMPTY then
		redim	fileArray(1 to 0)
		kill tmpfile
		exit sub
	end if
	
	dim fileHandle as long : fileHandle = file.OpenInput(tmpfile)
	dim count as integer : count = 0
	redim fileArray(listMAX)
	do while not eof(fileHandle) and count < listMAX
		count = count + 1
		input #fileHandle, fileArray(count)
	loop
	
	redim _preserve fileArray(count)
	if file.Close(fileHandle) then
		file.Delete(tmpfile)
	end if
	
end sub

$end if